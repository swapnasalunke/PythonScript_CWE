package Service.vulnerability.jwt.bean;

import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.nio.charset.StandardCharsets;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;

import Service.exception.ExceptionStatusCodeEnum;
import Service.exception.ServiceApplicationException;
import org.apache.commons.io.IOUtils;
public class JWTUtils {
    public static final char JWT_TOKEN_PERIOD_CHARACTER = '.';

    public static final String JWT_TOKEN_PERIOD_CHARACTER_REGEX =
            "[" + JWT_TOKEN_PERIOD_CHARACTER + "]";

    public static final String BASE64_PADDING_CHARACTER_REGEX = "=";

    public static final String NONE_ALGORITHM = "none";
    public static final String JWT_ALGORITHM_KEY_HEADER = "alg";
    public static final String JSON_WEB_KEY_HEADER = "jwk";
    public static final String JWT_RSA_ALGORITHM_IDENTIFIER = "RS";
    public static final String JWT_RSA_PSS_ALGORITHM_IDENTIFIER = "PS";
    public static final String JWT_HMAC_ALGORITHM_IDENTIFIER = "HS";
    public static final String JWT_EC_ALGORITHM_IDENTIFIER = "EC";
    public static final String JWT_OCTET_ALGORITHM_IDENTIFIER = "ED";
    public static final String JWT_HMAC_SHA_256_ALGORITHM = "HS256";
    // TODO need to make it better.
    public static final String HS256_TOKEN_TO_BE_SIGNED =
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9."
                    + "eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ";

    public static final String RS256_TOKEN_TO_BE_SIGNED =
            "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9."
                    + "eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0";

    public static final String GENERIC_BASE64_ENCODED_PAYLOAD =
            "eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG"
                    + "4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0";

    public static final String KEYS_LOCATION = "static/templates/JWTVulnerability/keys/";


    public static final String BEGIN_PRIVATE_KEY_TOKEN = "-----BEGIN PRIVATE KEY-----";

    public static final String END_PRIVATE_KEY_TOKEN = "-----END PRIVATE KEY-----";
    public static final String BEGIN_PUBLIC_KEY_TOKEN = "-----BEGIN PUBLIC KEY-----";
    public static final String END_PUBLIC_KEY_TOKEN = "-----END PUBLIC KEY-----";

    public static byte[] getBytes(String token) throws UnsupportedEncodingException {
        return token.getBytes(StandardCharsets.UTF_8);
    }

    public static String getString(byte[] tokenBytes) throws UnsupportedEncodingException {
        return new String(tokenBytes, StandardCharsets.UTF_8);
    }

    public static final Map<String, String> JWT_HMAC_ALGO_TO_JAVA_ALGORITHM_MAPPING =
            createJWTHmacAlgoToJavaAlgoMapping();

    static Map<String, String> createJWTHmacAlgoToJavaAlgoMapping() {
        Map<String, String> jwtAlgoToJavaAlgoMapping = new HashMap<String, String>();
        jwtAlgoToJavaAlgoMapping.put(JWT_HMAC_SHA_256_ALGORITHM, "HmacSHA256");
        jwtAlgoToJavaAlgoMapping.put("HS384", "HmacSHA384");
        jwtAlgoToJavaAlgoMapping.put("HS512", "HmacSHA512");
        return jwtAlgoToJavaAlgoMapping;
    }


    public static String getBase64UrlSafeWithoutPaddingEncodedString(String token)
            throws UnsupportedEncodingException {
        return JWTUtils.getBase64UrlSafeWithoutPaddingEncodedString(getBytes(token));
    }

    public static String getBase64UrlSafeWithoutPaddingEncodedString(byte[] token)
            throws UnsupportedEncodingException {
        return JWTUtils.getString(Base64.getUrlEncoder().encode(token))
                .replaceAll(BASE64_PADDING_CHARACTER_REGEX, "");
    }


    public static RSAPrivateKey getRSAPrivateKeyFromProvidedPEMFilePath(InputStream pemFile)
            throws ServiceApplicationException {
        try {
            String certAndKey = IOUtils.toString(pemFile, StandardCharsets.US_ASCII);
            byte[] keyBytes =
                    parseDERFromPEM(certAndKey, BEGIN_PRIVATE_KEY_TOKEN, END_PRIVATE_KEY_TOKEN);
            PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(keyBytes);
            KeyFactory factory = KeyFactory.getInstance("RSA");
            return (RSAPrivateKey) factory.generatePrivate(spec);
        } catch (IOException | NoSuchAlgorithmException | InvalidKeySpecException e) {
            throw new ServiceApplicationException(ExceptionStatusCodeEnum.SYSTEM_ERROR, e);
        }
    }


    public static RSAPublicKey getRSAPublicKeyFromProvidedPEMFilePath(InputStream pemFile)
            throws ServiceApplicationException {
        try {
            String certAndKey = IOUtils.toString(pemFile, StandardCharsets.US_ASCII);
            byte[] keyBytes =
                    parseDERFromPEM(certAndKey, BEGIN_PUBLIC_KEY_TOKEN, END_PUBLIC_KEY_TOKEN);
            X509EncodedKeySpec spec = new X509EncodedKeySpec(keyBytes);
            KeyFactory factory = KeyFactory.getInstance("RSA");
            return (RSAPublicKey) factory.generatePublic(spec);
        } catch (IOException | NoSuchAlgorithmException | InvalidKeySpecException e) {
            throw new ServiceApplicationException(ExceptionStatusCodeEnum.SYSTEM_ERROR, e);
        }
    }


    private static boolean containsSection(String contents, String beginToken, String endToken) {
        int idxToken;
        if ((idxToken = contents.indexOf(beginToken)) == -1
                || contents.indexOf(endToken) < idxToken) {
            return false;
        }
        return true;
    }


    private static byte[] parseDERFromPEM(String pem, String beginDelimiter, String endDelimiter) {
        if (!containsSection(pem, beginDelimiter, endDelimiter)) {
            return new byte[0];
        }
        String[] tokens = pem.split(beginDelimiter);
        tokens = tokens[1].split(endDelimiter);
        return Base64.getMimeDecoder().decode(tokens[0]);
    }
}


